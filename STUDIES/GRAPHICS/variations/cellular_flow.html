<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>P-doom Curve - Cellular Flow</title>
<style>
  body {margin:0;overflow:hidden;background:#000;color:#0cf;font-family:'Courier New',monospace;}
  #ui {position:fixed;top:10px;left:10px;background:rgba(0,15,20,0.9);padding:15px;border-radius:8px;
       border:1px solid #0cf;box-shadow:0 0 25px rgba(0,200,255,0.4);z-index:100;}
  label {display:block;margin:8px 0;font-size:11px;text-shadow:0 0 5px #0cf;}
  input[type="range"] {width:180px;}
  button {background:#068;border:1px solid #0cf;color:#0cf;padding:5px 10px;cursor:pointer;
          font-family:inherit;margin-top:5px;}
  button:hover {background:#0cf;color:#000;}
  canvas {position:absolute;top:0;left:0;}
  #graph {z-index:10;pointer-events:none;}
  #shader {z-index:1;}
</style>
</head>
<body>

<canvas id="shader"></canvas>
<canvas id="graph"></canvas>

<div id="ui">
  <label>b (exponent): <input type="range" id="b" min="-5" max="5" step="0.01" value="1"><span id="bval">1.00</span></label>
  <label>c (offset):   <input type="range" id="c" min="-5" max="5" step="0.01" value="0"><span id="cval">0.00</span></label>
  <label>x-offset:    <input type="range" id="dx" min="-10" max="10" step="0.01" value="0"><span id="dxval">0.00</span></label>
  <label>Break-y:     <input type="range" id="breakY" min="0" max="1" step="0.001" value="0.5"><span id="byval">0.50</span></label>
  <button id="reset">Reset to constraints</button>
</div>

<script>
/* ========== WebGL Shader Background ========== */
const shaderCanvas = document.getElementById('shader');
const gl = shaderCanvas.getContext('webgl');

function resizeShader() {
  shaderCanvas.width = window.innerWidth;
  shaderCanvas.height = window.innerHeight;
  if(gl) gl.viewport(0, 0, shaderCanvas.width, shaderCanvas.height);
}
window.addEventListener('resize', resizeShader);
resizeShader();

const vsSource = `
  attribute vec2 pos;
  void main() {
    gl_Position = vec4(pos, 0.0, 1.0);
  }
`;

// Fragment shader - cellular automaton fluid
const fsSource = `
  precision highp float;
  uniform vec2 resolution;
  uniform float time;

  float hash(vec2 p) {
    p = fract(p * vec2(234.567, 789.123));
    p += dot(p, p + 45.67);
    return fract(p.x * p.y);
  }

  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
  }

  // Cellular pattern with life-like behavior
  float cellular(vec2 p, float t) {
    vec2 cell = floor(p * 12.0);
    float state = hash(cell + floor(t * 2.0));

    // Count neighbors (simulated)
    float neighbors = 0.0;
    for(int j = -1; j <= 1; j++) {
      for(int i = -1; i <= 1; i++) {
        if(i == 0 && j == 0) continue;
        neighbors += hash(cell + vec2(float(i), float(j)) + floor(t * 2.0));
      }
    }

    // Conway-like rules approximation
    float alive = step(0.5, state);
    float willLive = step(0.4, neighbors / 8.0) * step(neighbors / 8.0, 0.6);

    return mix(alive, willLive, fract(t * 2.0));
  }

  // Fluid flow simulation
  vec2 fluidFlow(vec2 p, float t) {
    float n1 = noise(p * 2.0 + t * 0.2);
    float n2 = noise(p * 2.0 + t * 0.2 + 100.0);

    // Curl noise for divergence-free flow
    float dx = noise(vec2(p.x + 0.01, p.y) * 2.0 + t * 0.2) - n1;
    float dy = noise(vec2(p.x, p.y + 0.01) * 2.0 + t * 0.2) - n1;

    return vec2(dy, -dx) * 2.0;
  }

  // Membrane-like organic structures
  float membrane(vec2 p, float t) {
    float wave1 = sin(p.x * 4.0 + sin(p.y * 2.0 + t) + t * 1.5) * 0.5 + 0.5;
    float wave2 = sin(p.y * 5.0 + sin(p.x * 3.0 - t * 1.2) - t * 1.3) * 0.5 + 0.5;

    float membrane = wave1 * wave2;

    // Add vesicle-like structures
    float vesicles = 0.0;
    for(int i = 0; i < 5; i++) {
      float fi = float(i);
      vec2 center = vec2(
        sin(t * 0.3 + fi * 1.5) * 0.6,
        cos(t * 0.4 + fi * 2.0) * 0.6
      );
      float dist = length(p - center);
      vesicles += smoothstep(0.3, 0.2, dist) * 0.3;
    }

    return membrane + vesicles;
  }

  void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 p = uv * 2.0 - 1.0;
    p.x *= resolution.x / resolution.y;

    float t = time * 0.5;

    // Fluid flow field
    vec2 flow = fluidFlow(p, t);

    // Cellular automaton with flow
    float cells = cellular(p + flow * 0.2, t);

    // Organic membrane layer
    float memb = membrane(p + flow * 0.1, t);

    // Noise for texture
    float tex = noise(p * 8.0 + flow * 0.3 + t * 0.3);

    // Combine layers
    float pattern = cells * 0.5 + memb * 0.3 + tex * 0.2;

    // Color scheme: cyan (technology) to teal (biology)
    vec3 techColor = vec3(0.0, 0.8, 1.0);
    vec3 bioColor = vec3(0.0, 0.6, 0.5);
    vec3 darkColor = vec3(0.0, 0.2, 0.3);

    vec3 color = mix(darkColor, mix(bioColor, techColor, cells), pattern);

    // Add flow visualization
    float flowMag = length(flow);
    color += vec3(0.0, 0.2, 0.3) * flowMag * 0.1;

    // Pulsing
    color *= 0.85 + 0.15 * sin(t * 3.0 + pattern * 5.0);

    // Vignette
    float vignette = smoothstep(1.4, 0.3, length(p));
    color *= vignette;

    // Subtle scanlines
    color *= 0.98 + 0.02 * sin(uv.y * resolution.y * 1.5);

    gl_FragColor = vec4(color, 1.0);
  }
`;

function compileShader(source, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

const vs = compileShader(vsSource, gl.VERTEX_SHADER);
const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  console.error('Program link error:', gl.getProgramInfoLog(program));
}

gl.useProgram(program);

const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(program, 'pos');
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const resolutionLoc = gl.getUniformLocation(program, 'resolution');
const timeLoc = gl.getUniformLocation(program, 'time');

let startTime = Date.now();
function animateShader() {
  const time = (Date.now() - startTime) * 0.001;
  gl.uniform2f(resolutionLoc, shaderCanvas.width, shaderCanvas.height);
  gl.uniform1f(timeLoc, time);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(animateShader);
}
animateShader();

/* ========== Graph Canvas ========== */
const graphCanvas = document.getElementById('graph');
const ctx = graphCanvas.getContext('2d');

function resizeGraph() {
  graphCanvas.width = window.innerWidth;
  graphCanvas.height = window.innerHeight;
  draw();
}
window.addEventListener('resize', resizeGraph);
resizeGraph();

/* ========== UI ========== */
const sliders = {
  b: document.getElementById('b'),
  c: document.getElementById('c'),
  dx: document.getElementById('dx'),
  breakY: document.getElementById('breakY')
};

function updateDisplays() {
  document.getElementById('bval').textContent = parseFloat(sliders.b.value).toFixed(2);
  document.getElementById('cval').textContent = parseFloat(sliders.c.value).toFixed(2);
  document.getElementById('dxval').textContent = parseFloat(sliders.dx.value).toFixed(2);
  document.getElementById('byval').textContent = parseFloat(sliders.breakY.value).toFixed(3);
}

document.getElementById('reset').onclick = () => {
  const dx = parseFloat(sliders.dx.value);
  const target = 0.8;
  let b = 1.0;
  for(let i=0; i<20; i++) {
    const f = Math.pow(2027+dx, b) - Math.pow(2025+dx, b) - target;
    const df = Math.log(2027+dx)*Math.pow(2027+dx, b) - Math.log(2025+dx)*Math.pow(2025+dx, b);
    b -= f/df;
  }
  const c = 1 - Math.pow(2027+dx, b);
  sliders.b.value = b.toFixed(4);
  sliders.c.value = c.toFixed(4);
  updateDisplays();
  draw();
};

/* ========== Core math ========== */
function computeY(x, b, c, dx) {
  const X = new Float64Array(1);
  X[0] = x + dx;
  const y = Math.pow(X[0], b) + c;
  return y;
}

/* ========== Drawing ========== */
function draw() {
  const w = graphCanvas.width, h = graphCanvas.height;
  ctx.clearRect(0, 0, w, h);

  const b = parseFloat(sliders.b.value);
  const c = parseFloat(sliders.c.value);
  const dx = parseFloat(sliders.dx.value);
  const breakY = parseFloat(sliders.breakY.value);

  const years = [2020, 2030];
  const N = 2000;
  const step = (years[1] - years[0]) / N;

  // Draw curve with cyan glow
  ctx.lineWidth = 3;
  ctx.strokeStyle = '#00ccff';
  ctx.shadowBlur = 18;
  ctx.shadowColor = '#00ccff';
  ctx.beginPath();

  let started = false;
  for(let i = 0; i <= N; i++) {
    const x = years[0] + i * step;
    const y = computeY(x, b, c, dx);

    if(y < 0 || y > 1) continue;

    if(started && Math.abs(y - breakY) < 0.001) {
      ctx.stroke();
      ctx.beginPath();
      started = false;
    }

    const px = (x - years[0]) / (years[1] - years[0]) * w;
    const py = h - y * h;

    if(!started) {
      ctx.moveTo(px, py);
      started = true;
    } else {
      ctx.lineTo(px, py);
    }
  }
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Draw axes
  ctx.strokeStyle = '#00ccff44';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h);
  ctx.lineTo(w, h);
  ctx.moveTo(0, 0);
  ctx.lineTo(0, h);
  ctx.stroke();

  // Labels
  ctx.fillStyle = '#0cf';
  ctx.shadowBlur = 5;
  ctx.shadowColor = '#0cf';
  ctx.font = '14px "Courier New"';
  ctx.fillText('2020', 10, h - 10);
  ctx.fillText('2030', w - 50, h - 10);
  ctx.fillText('p=0', 10, h - 30);
  ctx.fillText('p=1', 10, 20);
  ctx.shadowBlur = 0;
}

/* ========== React to UI changes ========== */
Object.values(sliders).forEach(s => {
  s.addEventListener('input', () => {
    updateDisplays();
    draw();
  });
});
updateDisplays();
draw();
</script>
</body>
</html>
