<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>P-doom Curve - Neural Mesh</title>
<style>
  body {margin:0;overflow:hidden;background:#000;color:#f0f;font-family:'Courier New',monospace;}
  #ui {position:fixed;top:10px;left:10px;background:rgba(20,0,20,0.9);padding:15px;border-radius:8px;
       border:1px solid #f0f;box-shadow:0 0 25px rgba(255,0,255,0.4);z-index:100;}
  label {display:block;margin:8px 0;font-size:11px;text-shadow:0 0 5px #f0f;}
  input[type="range"] {width:180px;}
  button {background:#a0a;border:1px solid #f0f;color:#f0f;padding:5px 10px;cursor:pointer;
          font-family:inherit;margin-top:5px;}
  button:hover {background:#f0f;color:#000;}
  canvas {position:absolute;top:0;left:0;}
  #graph {z-index:10;pointer-events:none;}
  #shader {z-index:1;}
</style>
</head>
<body>

<canvas id="shader"></canvas>
<canvas id="graph"></canvas>

<div id="ui">
  <label>b (exponent): <input type="range" id="b" min="-5" max="5" step="0.01" value="1"><span id="bval">1.00</span></label>
  <label>c (offset):   <input type="range" id="c" min="-5" max="5" step="0.01" value="0"><span id="cval">0.00</span></label>
  <label>x-offset:    <input type="range" id="dx" min="-10" max="10" step="0.01" value="0"><span id="dxval">0.00</span></label>
  <label>Break-y:     <input type="range" id="breakY" min="0" max="1" step="0.001" value="0.5"><span id="byval">0.50</span></label>
  <button id="reset">Reset to constraints</button>
</div>

<script>
/* ========== WebGL Shader Background ========== */
const shaderCanvas = document.getElementById('shader');
const gl = shaderCanvas.getContext('webgl');

function resizeShader() {
  shaderCanvas.width = window.innerWidth;
  shaderCanvas.height = window.innerHeight;
  if(gl) gl.viewport(0, 0, shaderCanvas.width, shaderCanvas.height);
}
window.addEventListener('resize', resizeShader);
resizeShader();

const vsSource = `
  attribute vec2 pos;
  void main() {
    gl_Position = vec4(pos, 0.0, 1.0);
  }
`;

// Fragment shader - neural network mesh
const fsSource = `
  precision highp float;
  uniform vec2 resolution;
  uniform float time;

  float hash(vec2 p) {
    p = fract(p * vec2(123.45, 678.90));
    p += dot(p, p + 34.56);
    return fract(p.x * p.y);
  }

  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
  }

  // Voronoi cell noise for neural nodes
  vec2 voronoi(vec2 p) {
    vec2 n = floor(p);
    vec2 f = fract(p);

    float minDist = 10.0;
    vec2 minPoint = vec2(0.0);

    for(int j = -1; j <= 1; j++) {
      for(int i = -1; i <= 1; i++) {
        vec2 neighbor = vec2(float(i), float(j));
        vec2 point = hash(n + neighbor) * vec2(
          sin(time * 0.5 + hash(n + neighbor) * 6.28),
          cos(time * 0.5 + hash(n + neighbor + vec2(10.0, 10.0)) * 6.28)
        ) * 0.4;

        vec2 diff = neighbor + point - f;
        float dist = length(diff);

        if(dist < minDist) {
          minDist = dist;
          minPoint = point;
        }
      }
    }

    return vec2(minDist, hash(minPoint));
  }

  // Neural connection lines
  float neuralConnections(vec2 p, float t) {
    float scale = 3.0;
    vec2 vor = voronoi(p * scale);
    float nodes = vor.x;

    // Pulsing neurons
    float pulse = 0.5 + 0.5 * sin(t * 4.0 + vor.y * 20.0);
    float neuron = smoothstep(0.15, 0.08, nodes) * pulse;

    // Synaptic connections
    float connections = 0.0;
    float gridSize = 5.0;
    vec2 grid = fract(p * gridSize) - 0.5;

    // Horizontal axons
    float axonH = smoothstep(0.01, 0.0, abs(grid.y + sin(p.x * 3.0 + t) * 0.3));
    axonH *= 0.3 + 0.2 * sin(t * 3.0 + p.x * 10.0);

    // Vertical dendrites
    float axonV = smoothstep(0.01, 0.0, abs(grid.x + sin(p.y * 3.0 + t * 1.3) * 0.3));
    axonV *= 0.3 + 0.2 * sin(t * 3.0 + p.y * 10.0);

    connections = axonH + axonV;

    return neuron * 1.5 + connections;
  }

  // Organic wave distortion
  float organicWave(vec2 p, float t) {
    float wave = 0.0;
    wave += sin(p.x * 2.0 + t) * 0.5;
    wave += sin(p.y * 3.0 + t * 1.3) * 0.3;
    wave += sin((p.x + p.y) * 1.5 + t * 0.7) * 0.4;
    return wave / 3.0;
  }

  void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 p = uv * 2.0 - 1.0;
    p.x *= resolution.x / resolution.y;

    float t = time * 0.4;

    // Organic distortion
    vec2 distortion = vec2(
      organicWave(p + t * 0.1, t),
      organicWave(p.yx + t * 0.15, t + 100.0)
    );

    // Neural mesh with distortion
    float neural = neuralConnections(p + distortion * 0.3, t);

    // Add organic noise layer
    float organic = noise(p * 5.0 + t * 0.2) * 0.3;

    // Combine
    float pattern = neural + organic;

    // Color: magenta (neural) to blue (biological synapses)
    vec3 neuralColor = vec3(1.0, 0.0, 1.0);
    vec3 bioColor = vec3(0.3, 0.0, 0.8);
    vec3 color = mix(bioColor, neuralColor, neural);

    color *= pattern;

    // Pulse effect
    color *= 0.8 + 0.2 * sin(t * 2.0);

    // Vignette
    float vignette = smoothstep(1.3, 0.4, length(p));
    color *= vignette;

    // Subtle film grain
    float grain = hash(uv * time) * 0.05;
    color += grain;

    gl_FragColor = vec4(color, 1.0);
  }
`;

function compileShader(source, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

const vs = compileShader(vsSource, gl.VERTEX_SHADER);
const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  console.error('Program link error:', gl.getProgramInfoLog(program));
}

gl.useProgram(program);

const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(program, 'pos');
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const resolutionLoc = gl.getUniformLocation(program, 'resolution');
const timeLoc = gl.getUniformLocation(program, 'time');

let startTime = Date.now();
function animateShader() {
  const time = (Date.now() - startTime) * 0.001;
  gl.uniform2f(resolutionLoc, shaderCanvas.width, shaderCanvas.height);
  gl.uniform1f(timeLoc, time);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(animateShader);
}
animateShader();

/* ========== Graph Canvas ========== */
const graphCanvas = document.getElementById('graph');
const ctx = graphCanvas.getContext('2d');

function resizeGraph() {
  graphCanvas.width = window.innerWidth;
  graphCanvas.height = window.innerHeight;
  draw();
}
window.addEventListener('resize', resizeGraph);
resizeGraph();

/* ========== UI ========== */
const sliders = {
  b: document.getElementById('b'),
  c: document.getElementById('c'),
  dx: document.getElementById('dx'),
  breakY: document.getElementById('breakY')
};

function updateDisplays() {
  document.getElementById('bval').textContent = parseFloat(sliders.b.value).toFixed(2);
  document.getElementById('cval').textContent = parseFloat(sliders.c.value).toFixed(2);
  document.getElementById('dxval').textContent = parseFloat(sliders.dx.value).toFixed(2);
  document.getElementById('byval').textContent = parseFloat(sliders.breakY.value).toFixed(3);
}

document.getElementById('reset').onclick = () => {
  const dx = parseFloat(sliders.dx.value);
  const target = 0.8;
  let b = 1.0;
  for(let i=0; i<20; i++) {
    const f = Math.pow(2027+dx, b) - Math.pow(2025+dx, b) - target;
    const df = Math.log(2027+dx)*Math.pow(2027+dx, b) - Math.log(2025+dx)*Math.pow(2025+dx, b);
    b -= f/df;
  }
  const c = 1 - Math.pow(2027+dx, b);
  sliders.b.value = b.toFixed(4);
  sliders.c.value = c.toFixed(4);
  updateDisplays();
  draw();
};

/* ========== Core math ========== */
function computeY(x, b, c, dx) {
  const X = new Float64Array(1);
  X[0] = x + dx;
  const y = Math.pow(X[0], b) + c;
  return y;
}

/* ========== Drawing ========== */
function draw() {
  const w = graphCanvas.width, h = graphCanvas.height;
  ctx.clearRect(0, 0, w, h);

  const b = parseFloat(sliders.b.value);
  const c = parseFloat(sliders.c.value);
  const dx = parseFloat(sliders.dx.value);
  const breakY = parseFloat(sliders.breakY.value);

  const years = [2020, 2030];
  const N = 2000;
  const step = (years[1] - years[0]) / N;

  // Draw curve with magenta glow
  ctx.lineWidth = 3;
  ctx.strokeStyle = '#ff00ff';
  ctx.shadowBlur = 20;
  ctx.shadowColor = '#ff00ff';
  ctx.beginPath();

  let started = false;
  for(let i = 0; i <= N; i++) {
    const x = years[0] + i * step;
    const y = computeY(x, b, c, dx);

    if(y < 0 || y > 1) continue;

    if(started && Math.abs(y - breakY) < 0.001) {
      ctx.stroke();
      ctx.beginPath();
      started = false;
    }

    const px = (x - years[0]) / (years[1] - years[0]) * w;
    const py = h - y * h;

    if(!started) {
      ctx.moveTo(px, py);
      started = true;
    } else {
      ctx.lineTo(px, py);
    }
  }
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Draw axes
  ctx.strokeStyle = '#ff00ff44';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h);
  ctx.lineTo(w, h);
  ctx.moveTo(0, 0);
  ctx.lineTo(0, h);
  ctx.stroke();

  // Labels
  ctx.fillStyle = '#f0f';
  ctx.shadowBlur = 5;
  ctx.shadowColor = '#f0f';
  ctx.font = '14px "Courier New"';
  ctx.fillText('2020', 10, h - 10);
  ctx.fillText('2030', w - 50, h - 10);
  ctx.fillText('p=0', 10, h - 30);
  ctx.fillText('p=1', 10, 20);
  ctx.shadowBlur = 0;
}

/* ========== React to UI changes ========== */
Object.values(sliders).forEach(s => {
  s.addEventListener('input', () => {
    updateDisplays();
    draw();
  });
});
updateDisplays();
draw();
</script>
</body>
</html>
