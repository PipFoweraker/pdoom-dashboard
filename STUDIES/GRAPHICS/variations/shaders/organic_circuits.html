<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>P-doom Curve - Organic Circuits</title>
<style>
  body {margin:0;overflow:hidden;background:#000;color:#0f0;font-family:'Courier New',monospace;}
  #ui {position:fixed;top:10px;left:10px;background:rgba(0,20,10,0.85);padding:15px;border-radius:8px;
       border:1px solid #0f0;box-shadow:0 0 20px rgba(0,255,0,0.3);z-index:100;}
  label {display:block;margin:8px 0;font-size:11px;text-shadow:0 0 5px #0f0;}
  input[type="range"] {width:180px;}
  button {background:#0a4;border:1px solid #0f0;color:#0f0;padding:5px 10px;cursor:pointer;
          font-family:inherit;margin-top:5px;}
  button:hover {background:#0f0;color:#000;}
  canvas {position:absolute;top:0;left:0;}
  #graph {z-index:10;pointer-events:none;}
  #shader {z-index:1;}
</style>
</head>
<body>

<canvas id="shader"></canvas>
<canvas id="graph"></canvas>

<div id="ui">
  <label>b (exponent): <input type="range" id="b" min="-5" max="5" step="0.01" value="1"><span id="bval">1.00</span></label>
  <label>c (offset):   <input type="range" id="c" min="-5" max="5" step="0.01" value="0"><span id="cval">0.00</span></label>
  <label>x-offset:    <input type="range" id="dx" min="-10" max="10" step="0.01" value="0"><span id="dxval">0.00</span></label>
  <label>Break-y:     <input type="range" id="breakY" min="0" max="1" step="0.001" value="0.5"><span id="byval">0.50</span></label>
  <button id="reset">Reset to constraints</button>
</div>

<script>
/* ========== WebGL Shader Background ========== */
const shaderCanvas = document.getElementById('shader');
const gl = shaderCanvas.getContext('webgl');

function resizeShader() {
  shaderCanvas.width = window.innerWidth;
  shaderCanvas.height = window.innerHeight;
  if(gl) gl.viewport(0, 0, shaderCanvas.width, shaderCanvas.height);
}
window.addEventListener('resize', resizeShader);
resizeShader();

// Vertex shader
const vsSource = `
  attribute vec2 pos;
  void main() {
    gl_Position = vec4(pos, 0.0, 1.0);
  }
`;

// Fragment shader - organic circuit pattern
const fsSource = `
  precision highp float;
  uniform vec2 resolution;
  uniform float time;

  // Hash function for noise
  float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
  }

  // Smooth noise
  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);

    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
  }

  // Fractal brownian motion
  float fbm(vec2 p) {
    float value = 0.0;
    float amplitude = 0.5;
    for(int i = 0; i < 5; i++) {
      value += amplitude * noise(p);
      p *= 2.0;
      amplitude *= 0.5;
    }
    return value;
  }

  // Circuit pattern
  float circuits(vec2 p, float t) {
    vec2 grid = fract(p * 8.0) - 0.5;
    float d = length(grid);

    // Pulsing nodes
    float nodes = smoothstep(0.25, 0.15, d) * (0.5 + 0.5 * sin(t * 3.0 + d * 10.0));

    // Circuit traces
    float traces = 0.0;
    traces += smoothstep(0.02, 0.0, abs(grid.x)) * (0.3 + 0.2 * sin(t * 2.0 + p.y * 5.0));
    traces += smoothstep(0.02, 0.0, abs(grid.y)) * (0.3 + 0.2 * sin(t * 2.0 + p.x * 5.0));

    return nodes + traces;
  }

  void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 p = uv * 2.0 - 1.0;
    p.x *= resolution.x / resolution.y;

    float t = time * 0.3;

    // Organic flow field
    vec2 flow = vec2(
      fbm(p * 2.0 + t * 0.1),
      fbm(p * 2.0 + t * 0.1 + 100.0)
    );

    // Circuit layer with flow distortion
    float circ = circuits(p + flow * 0.3, t);

    // Organic undulation
    float organic = fbm(p * 3.0 + flow * 0.5 + t * 0.2);

    // Combine biological and technological
    float pattern = circ * 0.7 + organic * 0.3;

    // Color gradient: green (biological) to cyan (technological)
    vec3 bioColor = vec3(0.0, 0.8, 0.1);
    vec3 techColor = vec3(0.0, 0.6, 0.8);
    vec3 color = mix(bioColor, techColor, organic);

    // Apply pattern
    color *= pattern;

    // Subtle scan lines
    color *= 0.95 + 0.05 * sin(uv.y * resolution.y * 2.0);

    // Vignette
    float vignette = smoothstep(1.2, 0.3, length(p));
    color *= vignette;

    gl_FragColor = vec4(color, 1.0);
  }
`;

// Compile shader
function compileShader(source, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

const vs = compileShader(vsSource, gl.VERTEX_SHADER);
const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  console.error('Program link error:', gl.getProgramInfoLog(program));
}

gl.useProgram(program);

// Setup geometry
const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(program, 'pos');
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const resolutionLoc = gl.getUniformLocation(program, 'resolution');
const timeLoc = gl.getUniformLocation(program, 'time');

// Animation loop for shader
let startTime = Date.now();
function animateShader() {
  const time = (Date.now() - startTime) * 0.001;
  gl.uniform2f(resolutionLoc, shaderCanvas.width, shaderCanvas.height);
  gl.uniform1f(timeLoc, time);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(animateShader);
}
animateShader();

/* ========== Graph Canvas ========== */
const graphCanvas = document.getElementById('graph');
const ctx = graphCanvas.getContext('2d');

function resizeGraph() {
  graphCanvas.width = window.innerWidth;
  graphCanvas.height = window.innerHeight;
  draw();
}
window.addEventListener('resize', resizeGraph);
resizeGraph();

/* ========== UI ========== */
const sliders = {
  b: document.getElementById('b'),
  c: document.getElementById('c'),
  dx: document.getElementById('dx'),
  breakY: document.getElementById('breakY')
};

// Update value displays
function updateDisplays() {
  document.getElementById('bval').textContent = parseFloat(sliders.b.value).toFixed(2);
  document.getElementById('cval').textContent = parseFloat(sliders.c.value).toFixed(2);
  document.getElementById('dxval').textContent = parseFloat(sliders.dx.value).toFixed(2);
  document.getElementById('byval').textContent = parseFloat(sliders.breakY.value).toFixed(3);
}

document.getElementById('reset').onclick = () => {
  const dx = parseFloat(sliders.dx.value);
  const target = 0.8;
  let b = 1.0;
  for(let i=0; i<20; i++) {
    const f = Math.pow(2027+dx, b) - Math.pow(2025+dx, b) - target;
    const df = Math.log(2027+dx)*Math.pow(2027+dx, b) - Math.log(2025+dx)*Math.pow(2025+dx, b);
    b -= f/df;
  }
  const c = 1 - Math.pow(2027+dx, b);
  sliders.b.value = b.toFixed(4);
  sliders.c.value = c.toFixed(4);
  updateDisplays();
  draw();
};

/* ========== Core math ========== */
function computeY(x, b, c, dx) {
  const X = new Float64Array(1);
  X[0] = x + dx;
  const y = Math.pow(X[0], b) + c;
  return y;
}

/* ========== Drawing ========== */
function draw() {
  const w = graphCanvas.width, h = graphCanvas.height;
  ctx.clearRect(0, 0, w, h);

  const b = parseFloat(sliders.b.value);
  const c = parseFloat(sliders.c.value);
  const dx = parseFloat(sliders.dx.value);
  const breakY = parseFloat(sliders.breakY.value);

  const years = [2020, 2030];
  const N = 2000;
  const step = (years[1] - years[0]) / N;

  // Draw curve with glow
  ctx.lineWidth = 3;
  ctx.strokeStyle = '#00ff00';
  ctx.shadowBlur = 15;
  ctx.shadowColor = '#00ff00';
  ctx.beginPath();

  let started = false;
  for(let i = 0; i <= N; i++) {
    const x = years[0] + i * step;
    const y = computeY(x, b, c, dx);

    if(y < 0 || y > 1) continue;

    if(started && Math.abs(y - breakY) < 0.001) {
      ctx.stroke();
      ctx.beginPath();
      started = false;
    }

    const px = (x - years[0]) / (years[1] - years[0]) * w;
    const py = h - y * h;

    if(!started) {
      ctx.moveTo(px, py);
      started = true;
    } else {
      ctx.lineTo(px, py);
    }
  }
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Draw axes
  ctx.strokeStyle = '#00ff0055';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h);
  ctx.lineTo(w, h);
  ctx.moveTo(0, 0);
  ctx.lineTo(0, h);
  ctx.stroke();

  // Labels with glow
  ctx.fillStyle = '#0f0';
  ctx.shadowBlur = 5;
  ctx.shadowColor = '#0f0';
  ctx.font = '14px "Courier New"';
  ctx.fillText('2020', 10, h - 10);
  ctx.fillText('2030', w - 50, h - 10);
  ctx.fillText('p=0', 10, h - 30);
  ctx.fillText('p=1', 10, 20);
  ctx.shadowBlur = 0;
}

/* ========== React to UI changes ========== */
Object.values(sliders).forEach(s => {
  s.addEventListener('input', () => {
    updateDisplays();
    draw();
  });
});
updateDisplays();
draw();
</script>
</body>
</html>
