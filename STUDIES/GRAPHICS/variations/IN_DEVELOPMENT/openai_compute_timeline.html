<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>OpenAI Training Compute Timeline</title>
<style>
  body {margin:0;overflow:hidden;background:#0a0a0a;color:#00ff41;font-family:'Courier New',monospace;}
  #shader {position:absolute;top:0;left:0;z-index:1;}
  #chart {position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
          width:80%;max-width:1200px;height:70%;z-index:10;
          background:rgba(10,20,10,0.85);border:2px solid #00ff41;
          border-radius:10px;box-shadow:0 0 30px rgba(0,255,65,0.5);padding:20px;}
  #title {text-align:center;font-size:24px;margin-bottom:10px;text-shadow:0 0 10px #00ff41;}
  #subtitle {text-align:center;font-size:12px;margin-bottom:20px;opacity:0.7;}
  #graph {width:100%;height:calc(100% - 80px);}
  .point-label {font-size:10px;fill:#00ff41;text-shadow:0 0 5px #000;}
</style>
<script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
</head>
<body>

<canvas id="shader"></canvas>

<div id="chart">
  <div id="title">OpenAI Training Compute: 2018-2025</div>
  <div id="subtitle">Exponential Growth: ~5-6 Month Doubling Time</div>
  <div id="graph"></div>
</div>

<script>
/* ========== WebGL Shader Background (from neural_mesh_pdoom1.html) ========== */
const shaderCanvas = document.getElementById('shader');
const gl = shaderCanvas.getContext('webgl');

function resizeShader() {
  shaderCanvas.width = window.innerWidth;
  shaderCanvas.height = window.innerHeight;
  if(gl) gl.viewport(0, 0, shaderCanvas.width, shaderCanvas.height);
}
window.addEventListener('resize', resizeShader);
resizeShader();

const vsSource = `
  attribute vec2 pos;
  void main() {
    gl_Position = vec4(pos, 0.0, 1.0);
  }
`;

const fsSource = `
  precision highp float;
  uniform vec2 resolution;
  uniform float time;
  uniform float intensity;

  float hash(vec2 p) {
    p = fract(p * vec2(123.45, 678.90));
    p += dot(p, p + 34.56);
    return fract(p.x * p.y);
  }

  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    f = f * f * (3.0 - 2.0 * f);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
  }

  vec2 voronoi(vec2 p) {
    vec2 n = floor(p);
    vec2 f = fract(p);
    float minDist = 10.0;
    vec2 minPoint = vec2(0.0);
    for(int j = -1; j <= 1; j++) {
      for(int i = -1; i <= 1; i++) {
        vec2 neighbor = vec2(float(i), float(j));
        vec2 point = hash(n + neighbor) * vec2(
          sin(time * 0.3 + hash(n + neighbor) * 6.28),
          cos(time * 0.3 + hash(n + neighbor + vec2(10.0, 10.0)) * 6.28)
        ) * 0.4;
        vec2 diff = neighbor + point - f;
        float dist = length(diff);
        if(dist < minDist) {
          minDist = dist;
          minPoint = point;
        }
      }
    }
    return vec2(minDist, hash(minPoint));
  }

  float neuralConnections(vec2 p, float t) {
    float scale = 3.5;
    vec2 vor = voronoi(p * scale);
    float nodes = vor.x;
    float pulse = 0.3 + 0.2 * sin(t * 2.0 + vor.y * 15.0);
    float neuron = smoothstep(0.18, 0.12, nodes) * pulse;
    float connections = 0.0;
    float gridSize = 6.0;
    vec2 grid = fract(p * gridSize) - 0.5;
    float axonH = smoothstep(0.008, 0.0, abs(grid.y + sin(p.x * 2.5 + t * 0.5) * 0.25));
    axonH *= 0.2 + 0.1 * sin(t * 2.0 + p.x * 8.0);
    float axonV = smoothstep(0.008, 0.0, abs(grid.x + sin(p.y * 2.5 + t * 0.6) * 0.25));
    axonV *= 0.2 + 0.1 * sin(t * 2.0 + p.y * 8.0);
    connections = axonH + axonV;
    return neuron * 1.2 + connections;
  }

  float organicWave(vec2 p, float t) {
    float wave = 0.0;
    wave += sin(p.x * 1.8 + t * 0.5) * 0.4;
    wave += sin(p.y * 2.2 + t * 0.6) * 0.3;
    wave += sin((p.x + p.y) * 1.3 + t * 0.4) * 0.35;
    return wave / 3.5;
  }

  void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 p = uv * 2.0 - 1.0;
    p.x *= resolution.x / resolution.y;
    float t = time * 0.3;
    vec2 distortion = vec2(
      organicWave(p + t * 0.08, t),
      organicWave(p.yx + t * 0.1, t + 100.0)
    );
    float neural = neuralConnections(p + distortion * 0.2, t);
    float organic = noise(p * 4.0 + t * 0.15) * 0.15;
    float pattern = neural + organic;
    vec3 darkGreen = vec3(0.0, 0.15, 0.05);
    vec3 matrixGreen = vec3(0.0, 1.0, 0.25);
    vec3 teal = vec3(0.0, 0.4, 0.3);
    vec3 color = mix(darkGreen, teal, neural * 0.5);
    color = mix(color, matrixGreen, neural * neural * 0.3);
    color *= pattern * intensity;
    color *= 0.85 + 0.15 * sin(t * 1.5);
    float vignette = smoothstep(1.5, 0.3, length(p));
    color *= vignette;
    float grain = hash(uv * time) * 0.03;
    color += grain * intensity * 0.5;
    color *= 0.4;
    gl_FragColor = vec4(color, 1.0);
  }
`;

function compileShader(source, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

const vs = compileShader(vsSource, gl.VERTEX_SHADER);
const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  console.error('Program link error:', gl.getProgramInfoLog(program));
}

gl.useProgram(program);

const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(program, 'pos');
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const resolutionLoc = gl.getUniformLocation(program, 'resolution');
const timeLoc = gl.getUniformLocation(program, 'time');
const intensityLoc = gl.getUniformLocation(program, 'intensity');

let startTime = Date.now();
const intensity = 0.25; // Slightly darker for readability

function animateShader() {
  const time = (Date.now() - startTime) * 0.001;
  gl.uniform2f(resolutionLoc, shaderCanvas.width, shaderCanvas.height);
  gl.uniform1f(timeLoc, time);
  gl.uniform1f(intensityLoc, intensity);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(animateShader);
}
animateShader();

/* ========== OpenAI Model Data ========== */
const openaiModels = [
  {name: 'GPT-1', date: '2018-06-11', flops: 1e21, confidence: 'Medium'},
  {name: 'GPT-2', date: '2019-02-14', flops: 2.8e22, confidence: 'High'},
  {name: 'GPT-3', date: '2020-06-11', flops: 3.14e23, confidence: 'Very High'},
  {name: 'GPT-4', date: '2023-03-14', flops: 2.15e25, confidence: 'High'},
  {name: 'GPT-4o', date: '2024-05-13', flops: 5e25, confidence: 'Medium'},
  {name: 'o1', date: '2024-09-12', flops: 1e26, confidence: 'Low-Medium'},
  {name: 'GPT-4.5', date: '2025-02-27', flops: 3e26, confidence: 'Low'},
  {name: 'GPT-5', date: '2025-08-07', flops: 5e26, confidence: 'Medium'}
];

// Convert dates to days since 2018-01-01
const baseDate = new Date('2018-01-01');
const modelData = openaiModels.map(m => {
  const date = new Date(m.date);
  const daysSince = (date - baseDate) / (1000 * 60 * 60 * 24);
  return {
    ...m,
    daysSince,
    yearFraction: 2018 + daysSince / 365.25
  };
});

/* ========== Exponential Curve Fitting ========== */
// Fit exponential: FLOPS = a * exp(b * days)
// Using GPT-3 and GPT-4 as anchors (highest confidence)
const gpt3 = modelData.find(m => m.name === 'GPT-3');
const gpt4 = modelData.find(m => m.name === 'GPT-4');

// ln(FLOPS) = ln(a) + b * days
// Two points: solve for a and b
const b = (Math.log(gpt4.flops) - Math.log(gpt3.flops)) / (gpt4.daysSince - gpt3.daysSince);
const a = gpt3.flops / Math.exp(b * gpt3.daysSince);

// Doubling time in days
const doublingTime = Math.log(2) / b;
const doublingMonths = doublingTime / 30.44;

console.log(`Exponential fit: FLOPS = ${a.toExponential(2)} * exp(${b.toExponential(4)} * days)`);
console.log(`Doubling time: ${doublingMonths.toFixed(1)} months`);

// Generate smooth exponential curve
const curvePoints = [];
for(let day = 0; day <= 2800; day += 10) {
  const flops = a * Math.exp(b * day);
  const year = 2018 + day / 365.25;
  curvePoints.push({year, flops});
}

/* ========== Plotly Visualization ========== */
const trace1 = {
  x: curvePoints.map(p => p.year),
  y: curvePoints.map(p => p.flops),
  type: 'scatter',
  mode: 'lines',
  name: 'Exponential Trend',
  line: {
    color: '#00ff41',
    width: 3,
    shape: 'spline'
  },
  hovertemplate: '%{y:.2e} FLOPS<br>%{x:.1f}<extra></extra>'
};

const trace2 = {
  x: modelData.map(m => m.yearFraction),
  y: modelData.map(m => m.flops),
  type: 'scatter',
  mode: 'markers+text',
  name: 'OpenAI Models',
  marker: {
    size: 12,
    color: '#00ff41',
    symbol: 'circle',
    line: {
      color: '#0a0a0a',
      width: 2
    }
  },
  text: modelData.map(m => m.name),
  textposition: 'top center',
  textfont: {
    family: 'Courier New',
    size: 11,
    color: '#00ff41'
  },
  hovertemplate: '<b>%{text}</b><br>Training Compute: %{y:.2e} FLOPS<br>Date: %{x:.2f}<br><extra></extra>'
};

const layout = {
  xaxis: {
    title: {
      text: 'Year',
      font: {family: 'Courier New', size: 14, color: '#00ff41'}
    },
    gridcolor: '#00ff4133',
    tickfont: {family: 'Courier New', size: 11, color: '#00ff41'},
    range: [2017.5, 2026]
  },
  yaxis: {
    title: {
      text: 'Training Compute (FLOPS)',
      font: {family: 'Courier New', size: 14, color: '#00ff41'}
    },
    type: 'log',
    gridcolor: '#00ff4133',
    tickfont: {family: 'Courier New', size: 11, color: '#00ff41'},
    exponentformat: 'e'
  },
  plot_bgcolor: 'rgba(0,0,0,0)',
  paper_bgcolor: 'rgba(0,0,0,0)',
  font: {
    family: 'Courier New',
    color: '#00ff41'
  },
  legend: {
    x: 0.02,
    y: 0.98,
    font: {family: 'Courier New', size: 12, color: '#00ff41'},
    bgcolor: 'rgba(10,20,10,0.7)',
    bordercolor: '#00ff41',
    borderwidth: 1
  },
  margin: {l: 80, r: 40, t: 20, b: 60},
  hovermode: 'closest'
};

const config = {
  responsive: true,
  displayModeBar: false
};

Plotly.newPlot('graph', [trace1, trace2], layout, config);

// Update on window resize
window.addEventListener('resize', () => {
  Plotly.Plots.resize('graph');
});
</script>
</body>
</html>
