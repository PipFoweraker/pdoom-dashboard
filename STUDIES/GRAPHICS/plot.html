<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>P‑doom Curve Explorer</title>
<style>
  body {margin:0;background:#111;color:#ddd;font-family:sans-serif;}
  #ui {position:fixed;top:10px;left:10px;background:#222;padding:10px;border-radius:5px;}
  label {display:block;margin:5px 0;}
  canvas {display:block;}
</style>
</head>
<body>

<div id="ui">
  <label>b (exponent): <input type="range" id="b" min="-5" max="5" step="0.01" value="1"></label>
  <label>c (offset):   <input type="range" id="c" min="-5" max="5" step="0.01" value="0"></label>
  <label>x‑offset:    <input type="range" id="dx" min="-10" max="10" step="0.01" value="0"></label>
  <label>Break‑y:     <input type="range" id="breakY" min="0" max="1" step="0.001" value="0.5"></label>
  <button id="reset">Reset to constraints</button>
</div>

<canvas id="gl"></canvas>

<script>
/* ---------- Setup ---------- */
const canvas = document.getElementById('gl');
const ctx = canvas.getContext('2d');
function resize(){canvas.width = innerWidth; canvas.height = innerHeight;}
window.addEventListener('resize', resize); resize();

/* ---------- UI ---------- */
const sliders = {
  b: document.getElementById('b'),
  c: document.getElementById('c'),
  dx: document.getElementById('dx'),
  breakY: document.getElementById('breakY')
};
document.getElementById('reset').onclick = () => {
  // Solve for b and c that satisfy the two constraints
  //   1 = (2027+dx)^b + c
  //   0.2 = (2025+dx)^b + c
  // Subtract → 0.8 = [(2027+dx)^b - (2025+dx)^b]
  // Use simple numeric solve (Newton) for b, then compute c.
  const dx = parseFloat(sliders.dx.value);
  const target = 0.8;
  let b = 1.0;
  for(let i=0;i<20;i++){
    const f = Math.pow(2027+dx,b) - Math.pow(2025+dx,b) - target;
    const df = Math.log(2027+dx)*Math.pow(2027+dx,b) -
               Math.log(2025+dx)*Math.pow(2025+dx,b);
    b -= f/df;
  }
  const c = 1 - Math.pow(2027+dx,b);
  sliders.b.value = b.toFixed(4);
  sliders.c.value = c.toFixed(4);
  draw();
};

/* ---------- Core math (double precision) ---------- */
function computeY(x, b, c, dx){
  // Use Float64 for full double precision
  const X = new Float64Array(1);
  X[0] = x + dx;
  const y = Math.pow(X[0], b) + c;
  return y;
}

/* ---------- Drawing ---------- */
function draw(){
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#0ff';
  ctx.beginPath();

  const b = parseFloat(sliders.b.value);
  const c = parseFloat(sliders.c.value);
  const dx = parseFloat(sliders.dx.value);
  const breakY = parseFloat(sliders.breakY.value);

  const years = [2020,2030];
  const N = 2000;                     // points for smoothness
  const step = (years[1]-years[0])/N;

  let started = false;
  for(let i=0;i<=N;i++){
    const x = years[0] + i*step;
    const y = computeY(x,b,c,dx);

    // Clip to valid domain
    if(y<0 || y>1) continue;

    // Apply discontinuity: break the path when crossing breakY
    if(started && Math.abs(y - breakY) < 0.001){
      ctx.stroke(); ctx.beginPath(); started = false;
    }

    const px = (x - years[0])/(years[1]-years[0]) * w;
    const py = h - y * h;   // y=0 at bottom, y=1 at top

    if(!started){
      ctx.moveTo(px,py);
      started = true;
    }else{
      ctx.lineTo(px,py);
    }
  }
  ctx.stroke();

  /* ---- Axes ---- */
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 1;
  ctx.beginPath();
  // X‑axis (year)
  ctx.moveTo(0,h);
  ctx.lineTo(w,h);
  // Y‑axis (probability)
  ctx.moveTo(0,0);
  ctx.lineTo(0,h);
  ctx.stroke();

  // Labels
  ctx.fillStyle = '#aaa';
  ctx.font = '12px sans-serif';
  ctx.fillText('2020',0,h-5);
  ctx.fillText('2030',w-30,h-5);
  ctx.fillText('0',5, h-5);
  ctx.fillText('1',5,12);
}

/* ---------- React to UI changes ---------- */
Object.values(sliders).forEach(s=>s.addEventListener('input',draw));
draw();
</script>
</body>
</html>

